# TON Deep Documentation
Документация по внутренним компонентам ТОНа, которая поможет разобраться, как все работает.

## ADNL
Это протокол нижнего уровня, на котором построено все взаимодействие в сети TON, он может работать поверх любого протокола, но чаще всего применяется поверх TCP и UDP. UDP применяется для общения между нодами, а TCP для коммуникации с lite-клиентами. В данный момент в документации делается упор только на TCP реализацию.

Вместо адресов, узлы сети используют публичные ключи ed25519 и устанавливают соединение, используя общий ключ, полученный с помощью процедуры Диффи-Хелмана для эллиптических кривых - ECDH.

### Структура пакетов
Каждый ADNL пакет, кроме хэндшейка, имеет структуру:
* 4 байта размера пакета в little endian (N)
* 32 байта nonce [[?]](## "Случайные байты, для защиты от атак на чексумму")
* (N - 64) байт полезных данных
* 32 байта чексумма SHA256 от nonce и полезных данных

Весь пакет, включая размер, зашифрован **AES-CTR**.
После расшифровки - нужно обязательно проверить, сходится ли чексумма с данными, для проверки нужно просто посчитать чексумму самостоятельно и сравнить результат с тем, что у нас в пакете.

Хэндшейк пакет - исключение, он передается в частично открытом виде и описан в следующей главе.


### Установка соединения
Для установки соединения нам нужно знать ip, порт и публичный ключ сервера, и сгенерировать свой приватный и публичный ключ ed25519. 

Данные публичных серверов такие как ip, порт и ключ можно получить из [конфига](https://ton-blockchain.github.io/global.config.json). Айпи в конфиге в числовом виде, в нормальный вид его можно привести используя, например [этот инстурмент](https://www.browserling.com/tools/dec-to-ip). Публичный ключ в конфиге в base64 формате.

Клиент генерирует 160 случайных байт, часть из которых будет использоваться сторонами в качестве основы для AES шифрования. 

Из них создаются 2 постоянных AES-CTR шифра, которые будут использоваться сторонами для шифрования/дешифрования сообщений после хэндшейка.
* Шифр A - ключ 0 - 31 байты, iv 64 - 79 байты
* Шифр B - ключ 32 - 63 байты, iv 80 - 95 байты

Шифры применяются в таком порядке:
* Шифр A используется сервером для шифрования отправляемых сообщений.
* Шифр A используется клиентом для дешифрования полученных сообщений.
* Шифр B используется клиентом для шифрования отправляемых сообщений.
* Шифр B используется сервером для дешифрования полученных сообщений.

Для установки соединения клиент должен отправить хэндшейк пакет, содержащий:
* [32 байта] **Айди ключа сервера** [[Подробнее]](#%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B0%D0%B9%D0%B4%D0%B8-%D0%BA%D0%BB%D1%8E%D1%87%D0%B0)
* [32 байта] **Наш публичный ключ ed25519**
* [32 байта] **SHA256 хэш от наших 160 байт**
* [160 байт] **Наши 160 байт в зашифрованом виде** [[Подробнее]](#%D1%88%D0%B8%D1%84%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D0%B4%D0%B0%D0%BD%D0%BD%D1%8B%D1%85-handshake-%D0%BF%D0%B0%D0%BA%D0%B5%D1%82%D0%B0)


При получении хэндшейк пакета, сервер проделает те же самые действия у себя, получит ECDH ключ, расшифрует 160 байт и создаст 2 постоянных ключа. Если все получится, сервер ответит пустым ADNL пакетом, без полезных данных, для дешифровки которого (а также последующих) нужно использовать один из постоянных шифров. 

С этого момента можно считать соединение установленным.

## Обмен данными и TL схемы
После того как мы установили соединение, мы можем приступать к получению информации, для сериализации данных используется язык TL.

TL (Type Language) - это язык для описания структур данных.

Для структуризации полезных данных, при общении используются [TL схемы](https://github.com/ton-blockchain/ton/tree/master/tl/generate/scheme) и в качестве префикса - айди схемы в little endian, который вычисляется как crc32 с таблицой IEEEE от схемы.

TL оперирует 32 битными блоками, соответственно размер данных в TL должен быть кратен 4 байтам, если размер объекта не кратен 4, нам нужно добавить нужное количество нулевых байт до кратности. 

Для кодирования чисел всегда используется Little Endian порядок.

Более детально TL можно изучить в [документации Telegram](https://core.telegram.org/mtproto/TL) (опционально)

### Ping&Pong
Ping пакет, оптимально отправлять примерно раз в 5 секунд, это нужно для поддержания соединения пока обмен данными не происходит, иначе сервер оборвет соединение.

Ping пакет, как и все остальные, строится по стандартной схеме описаной [выше](#структура-пакетов) и в качестве полезных данных несет идентификатор и айди запроса. 

Найдем нужную схему для пинг запроса [тут](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L35) и вычислим айди схемы как
`crc32_IEEEE("tcp.ping random_id:long = tcp.Pong")`, при конвертации в байты с порядком little endian получим **9a2b084d**.

Таким образом наш ADNL ping пакет будет выглядеть так:
* 4 байта размера пакета в little endian -> 64 + (4+8) = **76**
* 32 байта nonce -> случайные 32 байта
* 4 байта ID TL схемы -> **9a2b084d**
* 8 байт айди запроса -> случайное число uint64 
* 32 байта чексумма SHA256 от nonce и полезных данных

Отправляем наш пакет и в ответ ждем [tcp.pong](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L23), `random_id` будет равен тому который мы отправили в ping.

### Получение информации от лайт сервера
Все запросы которые направлены на получение информации из блокчеина обернуты в [LiteServer Query](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/lite_api.tl#L83) схему, которая в свою очередь обернута в [ADNL Query](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/lite_api.tl#L22) схему.

LiteQuery:
`liteServer.query data:bytes = Object`, айди **df068c79**

ADNLQuery:
`adnl.message.query query_id:int256 query:bytes = adnl.Message`, айди **7af98bb4**

LiteQuery передается внутри ADNLQuery как `query:bytes`, а конечный запрос передается внутри LiteQuery как `data:bytes`.

##### Кодирование bytes в TL
Для кодирования массива байт нам нужно сначала определить его размер, если он меньше чем 254 байта, то используется кодирование с 1 байтом в качестве размера, если больше - то в качестве первого байта пишется 0xFE, как индикатор большого массива, и уже после него следуют 3 байта размера.

Например мы кодируем массив `[0xAA, 0xBB]`, его размер 2, мы используем 1 байт размера и далее пишем сами данные, получаем `[0x02, 0xAA, 0xBB]`, готово, но мы видим что финальный равен 3 и не кратен 4м байтам, нам нужно добавить 1 байт паддинга чтобы было 4, получаем: `[0x02, 0xAA, 0xBB, 0x00]`.

В случае если нам нужно закодировать массив размер которого будет равен, например 396, мы поступаем следующим образом: 396 >= 254, значит мы используем 3 байта для кодирование размера и 1 байт индикатор повышеного размера, получаем: **[0xFE, 0x8C, 0x01, 0x00, байты массива]**, 396+4 = 400, что кратно 4, выравнивать не нужно.

#### Получение полезных данных
Теперь, так как мы уже умеем формировать TL пакеты для Lite API, мы можем запросить информацию о текущем блоке мастерчеина TON. Блок мастерчеина используется во многих дальнейших запросах как входящий параметр, для индикации состояния (момента) в котором нам нужна информация.

##### getMasterchainInfo
Ищем нужную нам [TL схему](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/lite_api.tl#L60), вычисляем ее айди и строим пакет:

* 4 байта размера пакета в little endian -> 64 + (4+8) = **76**
* 32 байта nonce -> случайные 32 байта
* 4 байта ID ADNLQuery схемы -> **7af98bb4**
* 32 байта `query_id:int256` -> случайные 32 байта
* * 1 байт размер массива -> **12**
* * 4 байта ID LiteQuery схемы -> **df068c79**
* * * 1 байт размер массива -> **4**
* * * 4 байта ID getMasterchainInfo схемы -> **2ee6b589**
* * * 3 нулевых байта падинга (выравнивание к 8)
* * 3 нулевых байта падинга (выравнивание к 16)
* 32 байта чексумма SHA256 от nonce и полезных данных

## Технические детали реализации

#### Получение айди ключа
Айди ключа - это SHA256 хэш от 4 магических байт **[0xC6, 0xB4, 0x13, 0x48]** и **публичного ключа**

[Пример кода](https://github.com/xssnick/tonutils-go/blob/2b5e5a0e6ceaf3f28309b0833cb45de81c580acc/liteclient/crypto.go#L16)

#### Шифрование данных Handshake пакета
Хэндшейк пакет отправляется в полуоткрытом виде, зашифрованы только 160 байт, содержащие информацию о постоянных шифрах.

Чтобы их зашифровать, нам нужен AES-CTR шифр, для его получения нам нужен SHA256 хэш от 160 байт и [общий ключ ECDH](#%D0%BF%D0%BE%D0%BB%D1%83%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%89%D0%B5%D0%B3%D0%BE-%D0%BA%D0%BB%D1%8E%D1%87%D0%B0-%D0%BF%D0%BE-ecdh)

Шифр собирается следующим образом:
* ключ = (0 - 15 байты общего ключа) + (16 - 31 байты хэша)
* iv   = (0 - 3 байты хэша) + (20 - 31 байты общего ключа)

После того, как шифр собран, мы шифруем им наши 160 байт.

[Пример кода](https://github.com/xssnick/tonutils-go/blob/2b5e5a0e6ceaf3f28309b0833cb45de81c580acc/liteclient/connection.go#L361)

#### Получение общего ключа по ECDH
Для расчета общего ключа нам понадобится наш приватный ключ и публичный ключ сервера. 

Суть DH в получении общего секретного ключа, без разглашения приватной информации. Приведу пример, как это происходит, в максимально упрощенном виде.
Предположим, что нужно сгенерировать общий ключ между нами и сервером, процесс будет выглядеть так:
1. Мы генерируем секретное и публичное числа, например **6** и **7**
2. Сервер генерирует секретное и публичное числа, например **5** и **15**
3. Мы с сервером обмениваемся публичными числами, отправляем серверу **7**, он нам отправляет **15**.
4. Мы высчитываем: **7^6 mod 15 = 4**
5. Сервер высчитывает: **7^5 mod 15 = 7**
6. Обмениваемся полученными числами, мы серверу **4**, он нам **7**
7. Мы высчитываем **7^6 mod 15 = 4**
8. Сервер высчитывает: **4^5 mod 15 = 4**
9. Общий ключ = **4**

Детали самого ECDH будут опущены, чтобы не усложнять прочтение. Если интересно, то лучше почитать про это отдельно.

[Пример кода](https://github.com/xssnick/tonutils-go/blob/2b5e5a0e6ceaf3f28309b0833cb45de81c580acc/liteclient/crypto.go#L32)
