# TL-B
В данном разделе отдельно разобраны сложные и неочевидные TL-B структуры. Для начала рекомендую ознакомиться с [официальной документацией](https://ton.org/docs/learn/overviews/TL-B)

### Hashmap

В качестве примера работы со сложными TL-B струкутрами разберем `Hashmap`, который является структурой для хранения `dict` из FunC кода смарт контрактов.

Для сериализации Hashmap с фиксированой длиной ключа используются следующие TL-B структуры:
```
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X) 
           right:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;
hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;
```
Где корневой структурой является `HashmapE`. Он может иметь одно из состояний: `hme_empty` либо `hme_root`.

#### Пример парсинга Hashmap

Для примера рассмотрим следующий Cell, приведенный в двоичный вид.
```
1[1] -> {
  2[00] -> {
    7[1001000] -> {
      25[1010000010000001100001001],
      25[1010000010000000001101111]
    },
    28[1011100000000000001100001001]
  }
}
```

Данный Cell это `HashmapE` c размером ключа 8 бит, а его значения это `uint16` числа. Т.е `HashmapE 8 uint16`

Для его парсинга нам нужно заранее знать, какую структуру использовать, `hme_empty` либо `hme_root`. Мы можем определить это по префиксу, у empty это 1 бит равный 0 (`hme_empty$0`), у root это 1 бит равный 1 (`hme_root$1`). Читаем первый бит, он равен единице (`1[1]`), значит перед нами `hme_root`.

Заполним переменные структуры известными значениями, получаем:
`hme_root$1 {n:#} {X:Type} root:^(Hashmap 8 uint16) = HashmapE 8 uint16;`

1 бит префикс уже прочитан, то что внутри `{}` является условиями, и не читается (`{n:#}` обозначает что n это любое число uint32, `{X:Type}` обозначет что X это любой тип). Следующее что нам нужно прочитать - это `root:^(Hashmap 8 uint16)`, `^` обозначает ссылку, загрузим ее. Получаем:
```
2[00] -> {
    7[1001000] -> {
      25[1010000010000001100001001],
      25[1010000010000000001101111]
    },
    28[1011100000000000001100001001]
  }
```

##### Начинаем парсинг веток 
Согласно нашей схеме - это структура `Hashmap 8 uint16`. Заполним ее известными значениями, получим:
```
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l 8) 
          {8 = (~m) + l} node:(HashmapNode m uint16) = Hashmap 8 uint16;
```

Как мы видим, появились условные переменные `{l:#}` и `{m:#}` значения которых нам не известны, так же после чтения `label`, `n` у нас участвует в уравнении `{n = (~m) + l}`, в данном случае мы можем вычислить `l` и `m`, об этом нам говорит знак `~`.

Для определения значения `l` нам нужно загрузить `label:(HmLabel ~l uint16)`. `HmLabel` имеет 3 варианта структуры:
```
hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;
```
Вариант определятся по префиксу, в нашей корневой, на данный момент, ячейка 2 нулевых бита (`2[00]`). У нас только 1 вариант который имеет префикс начинающийся с 0, получается перед нами `hml_short$0`.

Заполним `hml_short` известными значениями:
```
hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= 8} s:(n * Bit) = HmLabel ~n 8
```

Нам не известен `n`, но так как он имеет символ `~`, мы можем его вычислить, для этого загружаем `len:(Unary ~n)`, [[Подробнее про Unary]](#unary).
В нашем случае у нас было `2[00]`, после опеределения типа `HmLabel` у нас остался 1 бит из двух, загружаем его и видим что это 0, значит наш вариант это `unary_zero$0`. Получается n из `HmLabel` равен нулю.

Дополним `hml_short` посчитаным значением n:
```
hml_short$0 {m:#} {n:#} len:0 {n <= 8} s:(0 * Bit) = HmLabel 0 8
```
Получается у нас пустой `HmLabel`, s = 0, соответственно загружать нечего.

Возвращаемся еще выше и дополняем нашу структуру посчитаным значением `l`:
```
hm_edge#_ {n:#} {X:Type} {l:0} {m:#} label:(HmLabel 0 8) 
          {8 = (~m) + 0} node:(HashmapNode m uint16) = Hashmap 8 uint16;
```
Теперь, когда мы посчитали `l`, мы можем посчитать и `m` используя уравнение `n = (~m) + 0`, т.е `m = n - 0`, m = n = 8.

Мы определили все неизвестные и теперь можем загружать `node:(HashmapNode 8 uint16)`. HashmapNode у нас имеет варианты:
```
hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X) 
           right:^(Hashmap n X) = HashmapNode (n + 1) X;
```
В данном случае вариант мы определяем не по префиксу, а по параметру, если n = 0, то у нас `hmn_leaf`, иначе `hmn_fork`. В нашем случае n = 8, у нас `hmn_fork`. Берем его и заполняем известные значения:
```
hmn_fork#_ {n:#} {X:uint16} left:^(Hashmap n uint16) 
           right:^(Hashmap n uint16) = HashmapNode (n + 1) uint16;
```
Здесь все не так очевидно, у нас `HashmapNode (n + 1) uint16`, это значит что результирующий n должен быть равен нашему параметру, т.е 8. Чтобы вычислить локальный n, нужно посчитать его: `n = (n_local + 1)` -> `n_local = (n - 1)` -> `n_local = (8 - 1)` -> `n_local = 7`.
```
hmn_fork#_ {n:#} {X:uint16} left:^(Hashmap 7 uint16) 
           right:^(Hashmap 7 uint16) = HashmapNode (7 + 1) uint16;
```
Теперь все просто, загружаем левую и правую ветку, и для каждой ветки [повторяем процесс](#пример-парсинга-hashmap).

##### Разберем загрузку значений
Продолжая предыдущий пример, разберем загрузку правой ветки, т.е `28[1011100000000000001100001001]` 

Перед нами опять `hm_edge`, заполним его известными значениями:
```
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l 7) 
          {7 = (~m) + l} node:(HashmapNode m uint16) = Hashmap 7 uint16;
```

Загружаем `HmLabel`, в этот раз перед нами `hml_long`, так как префикс равен `10`.
```
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
```
Заполним его:
```
hml_long$10 {m:#} n:(#<= 7) s:(n * Bit) = HmLabel ~n 7;
```
Перед нами новая конструкция - `n:(#<= 7)`, она обозначает число такого размера, который способен вместить 7, по сути это log2 от числа + 1. Но для простоты можно посчитать количество бит которое нужно чтобы записать число 7, 7 в бинарном виде это `111`, значит нам нужно 3 бита, `n = 3`. 
```
hml_long$10 {m:#} n:(## 3) s:(n * Bit) = HmLabel ~n 7;
```
Загружаем `n`, получаем `111`, то есть 7 (совпадение). Далее загружаем `s`, 7 бит - `0000000`. `s` это часть ключа. 

Возвращаемся наверх и заполняем полученый `l`:
```
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel 7 7) 
          {7 = (~m) + 7} node:(HashmapNode m uint16) = Hashmap 7 uint16;
```
Вычисляем `m`, `m = 7 - 7`, `m = 0`.

Так как `m = 0`, мы добрались до значения, и в качестве HashmapNode применима структура:
```
hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
```
Тут все просто, подставляем наш тип uint16, и загружаем значение, оставшиеся 16 бит `0000001100001001`, в десятичном виде это 777, наше значение.

Теперь восстановим ключ. Собираем воедино все части ключей идущие над нами (возвращаемся наверх по тому же пути), и добавляем по 1 биту за каждое ответвление, если мы шли по правой ветке, то добавляем 1, если по левой - 0. Если над нами был не пустой HmLabel, то добавляем его биты в ключ.

В нашем случае берем 7 бит из HmLabel `0000000`, и перед ними добавляем 1, за счет того что мы добрались до значения по правой ветке. Получаем 8 бит `10000000`, наш ключ это число `128`.

### Unary
Unary обычно используется для определения динамического размера, в таких структурах как `hml_short`.

Unary имеет 2 варианта:
```
unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);
```

С `unary_zero` все просто, если первый бит 0, значит искомое число это 0. 

`unary_succ`, устроен интереснее, он загружается рекурсивно 
и имеет значение `~(n + 1)`, это значит что он вызывает сам себя до тех пор пока мы не наткнемся на `unary_zero`, иными словами, искомое значение будет равно количеству единиц идущих подряд. 

Разберем парсинг `1110`.

Цепочка вызовов будет следующая:
```unary_succ$1 -> unary_succ$1 -> unary_succ$1 -> unary_zero$0```

Как только мы дошли до `unary_zero`, значение возвращается наверх, как в рекурсивном вызове функции.
Теперь, чтобы понять результат, пойдем по пути возвращаемого значения, тоесть с конца:
```0 -> ~(0 + 1) -> ~(1 + 1) -> ~(2 + 1) -> 3```

