# TL-B

### Hashmap

В качестве примера расботы со сложными TL-B струкутрами разберем Hashmap, который является структурой для хранения dict из FunC кода смарт контрактов.

Для сериализации Hashmap с фиксированой длиной ключа используются следующие TL-B структуры:
```
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X) 
           right:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;
hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;
```
Где корневой структурой является `HashmapE`. Он может иметь одно из состояний: `hme_empty` либо `hme_root`.

#### Пример парсинга Hashmap

Для примера рассмотрим следующий Cell, приведенный в двоичный вид.
```
1[1] -> {
  2[00] -> {
    7[1001000] -> {
      25[1010000010000001100001001],
      25[1010000010000000001101111]
    },
    28[1011100000000000001100001001]
  }
}
```

Данный Cell это `HashmapE` c размером ключа 8 бит, а его значения это `uint16` числа. Т.е `HashmapE 8 uint16`

Для его парсинга нам нужно заранее знать, какую структуру использовать, `hme_empty` либо `hme_root`. Мы можем сделать это по префиксу, у первой это 1 бит равный 0 (`hme_empty$0`), у второй это 1 бит равный 1 (`hme_root$1`). Читаем первый бит, как мы видим он равен единице (`1[1]`), значит перед нами `hme_root`.

Заполним переменные структуры известными значениями, получаем:
`hme_root$1 {n:8} {X:uint16} root:^(Hashmap 8 uint16) = HashmapE 8 uint16;`

1 бит префикс уже прочитан, то что внутри `{}` является условиями, и не читается (`{n:#}` обозначает что n это любое число uint32, `{X:uint16}` обозначет что X это любой тип). Следующее что нам нужно прочитать - это `root:^(Hashmap 8 uint16)`, `^` обозначает ссылку, загрузим ее. Получаем:
```
2[00] -> {
    7[1001000] -> {
      25[1010000010000001100001001],
      25[1010000010000000001101111]
    },
    28[1011100000000000001100001001]
  }
```

Согласно нашей схеме - это структура `Hashmap 8 uint16`. Заполним ее известными значениями, получим:
```
hm_edge#_ {n:8} {X:uint16} {l:#} {m:#} label:(HmLabel ~l 8) 
          {n = (~m) + l} node:(HashmapNode m uint16) = Hashmap 8 uint16;
```

Как мы видим, появились условные переменные `{l:#}` и `{m:#}` значения которых нам не известны, но в данном случае мы можем их вычислить, об этом нам говорит знак `~`.
