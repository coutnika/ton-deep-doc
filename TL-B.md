# TL-B

### Hashmap

В качестве примера расботы со сложными TL-B струкутрами разберем Hashmap, который является структурой для хранения dict из FunC кода смарт контрактов.

Для сериализации Hashmap с фиксированой длиной ключа используются следующие TL-B структуры:
```
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l n) 
          {n = (~m) + l} node:(HashmapNode m X) = Hashmap n X;

hmn_leaf#_ {X:Type} value:X = HashmapNode 0 X;
hmn_fork#_ {n:#} {X:Type} left:^(Hashmap n X) 
           right:^(Hashmap n X) = HashmapNode (n + 1) X;

hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;

unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);

hme_empty$0 {n:#} {X:Type} = HashmapE n X;
hme_root$1 {n:#} {X:Type} root:^(Hashmap n X) = HashmapE n X;
```
Где корневой структурой является `HashmapE`. Он может иметь одно из состояний: `hme_empty` либо `hme_root`.

#### Пример парсинга Hashmap

Для примера рассмотрим следующий Cell, приведенный в двоичный вид.
```
1[1] -> {
  2[00] -> {
    7[1001000] -> {
      25[1010000010000001100001001],
      25[1010000010000000001101111]
    },
    28[1011100000000000001100001001]
  }
}
```

Данный Cell это `HashmapE` c размером ключа 8 бит, а его значения это `uint16` числа. Т.е `HashmapE 8 uint16`

Для его парсинга нам нужно заранее знать, какую структуру использовать, `hme_empty` либо `hme_root`. Мы можем определить это по префиксу, у empty это 1 бит равный 0 (`hme_empty$0`), у root это 1 бит равный 1 (`hme_root$1`). Читаем первый бит, он равен единице (`1[1]`), значит перед нами `hme_root`.

Заполним переменные структуры известными значениями, получаем:
`hme_root$1 {n:#} {X:Type} root:^(Hashmap 8 uint16) = HashmapE 8 uint16;`

1 бит префикс уже прочитан, то что внутри `{}` является условиями, и не читается (`{n:#}` обозначает что n это любое число uint32, `{X:Type}` обозначет что X это любой тип). Следующее что нам нужно прочитать - это `root:^(Hashmap 8 uint16)`, `^` обозначает ссылку, загрузим ее. Получаем:
```
2[00] -> {
    7[1001000] -> {
      25[1010000010000001100001001],
      25[1010000010000000001101111]
    },
    28[1011100000000000001100001001]
  }
```

Согласно нашей схеме - это структура `Hashmap 8 uint16`. Заполним ее известными значениями, получим:
```
hm_edge#_ {n:#} {X:Type} {l:#} {m:#} label:(HmLabel ~l 8) 
          {n = (~m) + l} node:(HashmapNode m uint16) = Hashmap n uint16;
```

Как мы видим, появились условные переменные `{l:#}` и `{m:#}` значения которых нам не известны, так же после чтения `label`, `n` у нас переопределяется на `{n = (~m) + l}` используя не известные значения, но в данном случае мы можем их вычислить, об этом нам говорит знак `~`.

Для определения значения `l` нам нужно загрузить `label:(HmLabel ~l uint16)`. `HmLabel` имеет 3 варианта структуры:
```
hml_short$0 {m:#} {n:#} len:(Unary ~n) {n <= m} s:(n * Bit) = HmLabel ~n m;
hml_long$10 {m:#} n:(#<= m) s:(n * Bit) = HmLabel ~n m;
hml_same$11 {m:#} v:Bit n:(#<= m) = HmLabel ~n m;
```
Вариант определятся по префиксу, в нашей корневой, на данный момент, ячейка 2 нулевых бита (`2[00]`). У нас только 1 вариант который имеет префикс начинающийся с 0, получается перед нами `hml_short$0`.

Заполним `hml_short` известными значениями:
```
hml_short$0 {m:8} {n:#} len:(Unary ~n) {n <= 8} s:(n * Bit) = HmLabel ~n 8
```

Нам не известен `n`, но так как он имеет символ `~`, мы можем его вычислить, для этого загружаем `len:(Unary ~n)`, [[Подробнее про Unary]](#unary).
В нашем случае у нас было `2[00]`, после опеределения типа `HmLabel` у нас остался 1 бит из двух, загружаем его и видим что это 0, значит наш вариант это `unary_zero$0`. Получается n из `HmLabel` равен нулю.

### Unary
Unary обычно используется для определения динамического размера, в таких структурах как `hml_short`.

Unary имеет 2 варианта:
```
unary_zero$0 = Unary ~0;
unary_succ$1 {n:#} x:(Unary ~n) = Unary ~(n + 1);
```

С `unary_zero` все просто, если первый бит 0, значит искомое число это 0. 

`unary_succ`, устроен интереснее, он загружается рекурсивно 
и имеет значение `~(n + 1)`, это значит что он вызывает сам себя до тех пор пока мы не наткнемся на `unary_zero`, иными словами, искомое значение будет равно количеству единиц идущих подряд. 

Пример:
`1110`

Цепочка вызовов будет следующая:
```unary_succ$1 -> unary_succ$1 -> unary_succ$1 -> unary_zero$0```

Как только мы дошли до `unary_zero`, значение возвращается наверх, как в рекурсивном вызове функции.
Теперь, чтобы понять результат, пойдем по пути возвращаемого значения, тоесть с конца:
```0 -> ~(0 + 1) -> ~(1 + 1) -> ~(2 + 1) -> 3```

