## Cell
Cell - это ячейка, контейнер для данных который может хранить до 1023 битов и иметь до 4х ссылок на другие Cell'ы. В ТОНе все состоит из целлов, код контрактов, хранимые данные, блоки. За счет такого подхода достигается универсальность.

## Bag of Cells
Bag of Cells - формат сериализации ячеек (cells) в массив байт, описанный в виде [TL-B схемы](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25).

#### Сериализация ячеек
Разберем ячейку вида:
```
1[8_] -> {
  24[0AAAAA],
  7[FE] -> {
    24[0AAAAA]
  }
}
```
Тут мы имеем корневую ячейку размером 1 бит, которая имеет 2 ссылки: первая на ячейку размером 24 бита и вторая на ячейку размером 7 бит, которая имеет 1 ссылку на ячейку размером 24 бита.

Нам нужно превратить ячейки в плоский набор байтов, для этого нам сначала нам нужно оставить только уникальные ячейки - их у нас 3 из 4х. Имеем:
```
1[8_]
24[0AAAAA]
7[FE]
```
Теперь расположим их в таком порядке, чтобы родительские ячейки не указывали назад. Та ячейка, на которую указывают остальные, должна быть в списке после тех, которые на нее указывают. Получаем:
```
1[8_]      -> индекс 0 (корневая ячейка)
7[FE]      -> индекс 1
24[0AAAAA] -> индекс 2
```

Посчитаем дескрипторы для каждой из них. Это 2 байта, хранящие флаги, информацию о длине данных и количестве ссылок. Флаги будут опущены в текущем разборе, они почти всегда 0. Первый байт содержит 5 битов флагов и 3 бита количества ссылок. Второй байт - длину полных 4х битных групп (но минимум 1, если не пусто). Получаем:
```
1[8_]      -> 0201 -> 2 ссылки, длина 1 
7[FE]      -> 0101 -> 1 ссылка, длина 1
24[0AAAAA] -> 0006 -> 0 ссылок, длина 6
```
Для данных с неполными 4х битными группами добавляется 1 бит в конец. Он означает конечный бит группы и служит для определения настоящего размера неполных групп. Добавим его:
```
1[8_]      -> C0     -> 0b10000000->0b11000000
7[FE]      -> FF     -> 0b11111110->0b11111111
24[0AAAAA] -> 0AAAAA -> не меняем (полные группы)
```

Теперь добавим индексы ссылок:
```
0 1[8_]      -> 0201 -> ссылается на 2 ячейки с такими индексами
1 7[FE]      -> 02 -> ссылается на ячейки с индексом 2
2 24[0AAAAA] -> нет ссылок
```

И соберем все вместе:
```
0201 C0     0201  
0101 AA     02
0006 0AAAAA 
```

И склеим в массив байт:
`0201c002010101ff0200060aaaaa`, размер 14 байт.

[Пример сериализации](https://github.com/xssnick/tonutils-go/blob/3d9ee052689376061bf7e4a22037ff131183afad/tvm/cell/serialize.go#L205)

#### Упаковка в BoC
Упакуем ячейку из прошлой главы. Мы уже сериализовали ее в плоский массив байт длиной 14.

Строим заголовок согласно [схеме](https://github.com/ton-blockchain/ton/blob/24dc184a2ea67f9c47042b4104bbb4d82289fac1/crypto/tl/boc.tlb#L25).

```
b5ee9c72                      -> id tl-b структуры BoC
01                            -> флаги и размер size:(## 3), в нашем случае флаги все 0, 
                                 и количество байтов нужное для хранения количества ячеек - 1.
                                 получаем - 0b0_0_0_00_001
01                            -> кол-во байтов для хранения размера сериализованых ячеек
03                            -> количество ячеек, 1 байт (определяется 3 битами size:(## 3), равный 3м.
01                            -> количество корневых ячеек - 1
00                            -> absent, всегда 0 (в текущих имплементациях)
0e                            -> размер сериализованых ячеек, 1 байт (размер определен выше), равный 14
00                            -> индекс корневой ячейки, размером 1 (определяется 3 битами size:(## 3) из заголовка), 
                                 всегда 0
0201c002010101ff0200060aaaaa  -> сериализованые ячейки
```

Всё, что выше, склеим в массив байтов и получим:
`b5ee9c7201010301000e000201c002010101ff0200060aaaaa` Это наш финальный BoC!

Примеры реализации BoC: [Сериализация](https://github.com/xssnick/tonutils-go/blob/master/tvm/cell/serialize.go), [Десериализация](https://github.com/xssnick/tonutils-go/blob/master/tvm/cell/parse.go)
