# DHT

DHT - Расшифровывается как Distributed Hash Table, и по сути представляет из себя распределенную базу данных ключ-значение, 
где каждый участник сети может что то сохранить, например информацию о себе.

Реализация DHT в TON по своей сути похожа на реализацию [Kademlia](https://codethechange.stanford.edu/guides/guide_kademlia.html) который используется в IPFS.
Любой участник сети может запустить DHT ноду, сгенерировать ключи, и хранить данные. 
Для этого ему нужно сгенерировать случайный айди, и сообщить о себе другим нодам.

Для определения на какой ноде сохранить данные, используется алгоритм определения "расстояния" между нодой и ключем. 
Алгоритм прост, берем айди ноды и айди ключа, производим операцию XOR, чем меньше получилось значение, тем ближе нода.
Задача в том чтобы сохранить ключ на максимально близким к ключу нодам, чтобы другие участники сети могли используя 
тот же алгоритм найти ноду которая сможет отдать данные по этому ключу.

### Поиск значения по ключу
Разберем пример с поиском ключа, [подключимся к любой DHT ноде и установим соединение по ADNL UDP](/ADNL-UDP-Internal.md#устройство-пакетов-и-обмен-информацией).

Например мы хотим найти адрес и данные для подключения к RLDP ноде ТОН сайта foundation.ton. Допустим мы уже получили ADNL адрес этого сайта, выполнив Get метод DNS контракта. ADNL адресом в hex представлении будет `516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174`. Теперь наша задача найти ip, порт и публичный ключ ноды имеющей этот адрес.

Чтобы это сделать, нам нужно получить ID DHT ключа, сначала соберем сам DHT ключ:
```
dht.key id:int256 name:bytes idx:int = dht.Key
```
`name` - это тип ключа, для ADNL адресов используется слово `address`, а, например, для поиска нод шардчеина - `nodes`. Но типом ключа может быть любой массив байтов, зависит от искомого значения.

Заполнив эту схему получим:
```
8fde67f6                                                           -- TL ID dht.key
516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174   -- наш искомый ADNL адрес
07 61646472657373                                                  -- тип ключа, слово "address" в виде массива bytes
00000000                                                           -- индекс 0 т.к ключ всего 1
```
Далее - получим айди ключа, sha256 хеш от сериализованых выше байтов. Это будет `b30af0538916421b46df4ce580bf3a29316831e0c3323a7f156df0236c5b2f75`

Теперь мы можем приступить к поиску, для этого нам нужно выполнить запрос имеющий [схему](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L197):
```
dht.findValue key:int256 k:int = dht.ValueResult
```
`key` - это айди нашего DHT ключа, а `k` - это "ширина" поиска, чем она меньше тем точнее, но меньше потенциальных нод для опроса. Максимальное k для нод в тоне равно 10, мы можем использовать 6.

Заполним эту структуру, сериализуем и отправим запрос используя схему `adnl.message.query`. [Подробнее об этом можну узнать в другой статье.](/ADNL-UDP-Internal.md#устройство-пакетов-и-обмен-информацией).

В ответ мы можем получить:
* `dht.valueNotFound` - если значение не найдено. 
* `dht.valueFound` - если значение найдено на этой ноде.

##### dht.valueNotFound
Если мы получили `dht.valueNotFound`, ответ будет содержать список нод которые известны запрошеной нами ноде и находятся максимально близко запрошеному нами ключу из списка известных ей нод. В этом случае нам нужно подключиться и добавить полученые ноды к списку известных нам. После этого из списка всех известных нам нод выбрать самую близкую, доступную и еще не опрошеную, и сделать также же запрос к ней. И так пока мы не попробуем все ноды в выбраном нами диапозоне или пока мы не перестанем получать новые ноды.

Разберем поля ответа подробнее, исползуемые схемы:
```
adnl.address.udp ip:int port:int = adnl.Address;
adnl.addressList addrs:(vector adnl.Address) version:int reinit_date:int priority:int expire_at:int = adnl.AddressList;

dht.node id:PublicKey addr_list:adnl.addressList version:int signature:bytes = dht.Node;
dht.nodes nodes:(vector dht.node) = dht.Nodes;

dht.valueNotFound nodes:dht.nodes = dht.ValueResult;
```
`dht.nodes -> nodes` -  список DHT нод (массив).

У каждой ноды есть `id` который является ее публичным ключем, обычно [pub.ed25519](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L47), используется как ключ сервера для подключения к ноде по ADNL. Так же каждая нода имеет список адресов `addr_list:adnl.addressList`, версию и подпись.

Нам нужно обязательно проверять подпись каждой ноды, для этого читаем значение `signature` и обнуляем поле (делаем пустым массивом bytes). После - сериализуем TL структуру `dht.node` с обнуленной подписью, и проверяем `signature` которая была до обнуления на полученных сериализованых байтах, используя ключ из `id`. [[Пример реализации]](https://github.com/xssnick/tonutils-go/blob/udp-rldp-2/adnl/dht/client.go#L91)

Из списка `addrs:(vector adnl.Address)` берем адрес и пробуем установить ADNL UDP соединение, в качестве ключа сервера используем `id` который является публичным ключем.

Чтобы узнать "расстояние" до этой ноды - нам нужно взять [айди ключа](/ADNL-TCP-Liteserver.md#получение-айди-ключа) от ключа из поля `id`, и проверить расстояние операцией XOR от айди ключа ноды и искомого ключа. Если расстояние достаточно небольшое - мы можем делать тот же запрос на эту ноду. И так далее, пока не найдем значение или не будет больше новых нод.

##### dht.valueFound
Ответ будет содержать само значение, полную информацию по ключу и, опционально, подпись. 

Разберем поля ответа подробнее, исползуемые схемы:
```
adnl.address.udp ip:int port:int = adnl.Address;
adnl.addressList addrs:(vector adnl.Address) version:int reinit_date:int priority:int expire_at:int = adnl.AddressList;

dht.key id:int256 name:bytes idx:int = dht.Key;

dht.updateRule.signature = dht.UpdateRule;
dht.updateRule.anybody = dht.UpdateRule;
dht.updateRule.overlayNodes = dht.UpdateRule;

dht.keyDescription key:dht.key id:PublicKey update_rule:dht.UpdateRule signature:bytes = dht.KeyDescription;

dht.value key:dht.keyDescription value:bytes ttl:int signature:bytes = dht.Value; 

dht.valueFound value:dht.Value = dht.ValueResult;
```
Для начала разберем `key:dht.keyDescription`, он представляет из себя полное описание ключа, сам ключ, информацию о том кто и как может обновлять значение.

* `key:dht.key` - ключ, должен полностью совпадать с тем от чего мы брали айди ключа для поиска. 
* `id:PublicKey` - публичный ключ владельца записи. 
* `update_rule:dht.UpdateRule` - правило обновления записи
* * `dht.updateRule.signature` - обновлять запись может только владелец приватного ключа, `signature` как ключа, так и значения должна быть валидной
* * `dht.updateRule.anybody` - обновлять запись могут все, `signature` пуста и не проверяется
* * `dht.updateRule.overlayNodes` - обновлять ключ могут только ноды из одного воркчеина

###### dht.updateRule.signature
После чтения описания ключа - мы действуем в зависимости от `updateRule`, для кейса с поиском ADNL адреса тип всегда - `dht.updateRule.signature`. Проверяем подпись ключа тем же способом что и в прошлый раз, делаем подпись пустым массивом байтов, сериализуем и проверяем. После - повторяем тоже самое для значения, т.е для всего объекта `dht.value` (подпись ключа при этом возвращаем на место).

[[Пример реализации]](https://github.com/xssnick/tonutils-go/blob/udp-rldp-2/adnl/dht/client.go#L331)

###### dht.updateRule.overlayNodes
```
overlay.node.toSign id:adnl.id.short overlay:int256 version:int = overlay.node.ToSign;
overlay.node id:PublicKey overlay:int256 version:int signature:bytes = overlay.Node;
overlay.nodes nodes:(vector overlay.node) = overlay.Nodes;
```

Используется для поиска других нод воркчеина в сети, в значении всегда имеет TL структуру `overlay.nodes`. Подпись значения должна быть пустой. Валидность записи проверяется 

TODO

###### dht.updateRule.anybody
Подписей нет, обновлять может любой, но реального использования я не видел.

##### Использование значения

Когда все верифицировано и время жизни значения `ttl:int` не просрочено - мы можем начинать работать с самим значением, т.е `value:bytes`. Для ADNL адреса там внутри должна быть структура `adnl.addressList`. В ней будут ip адреса и порты серверов соответствующих запрошеному ADNL адресу. В нашем случае там скорее всего будет 1 адрес RLDP-HTTP сервиса `foundation.ton`. В качестве ключа сервера мы будем использовать публичный ключ `id:PublicKey` из информации о ключе DHT.

После установки соединения - мы можем запрашивать страницы сайта используя протокол RLDP. Задача DHT на этом этапе выполнена.
