# DHT

DHT - Расшифровывается как Distributed Hash Table, и по сути представляет из себя распределенную базу данных ключ-значение, 
где каждый участник сети может что то сохранить, например информацию о себе.

Реализация DHT в TON по своей сути похожа на реализацию [Kademlia](https://codethechange.stanford.edu/guides/guide_kademlia.html) который используется в IPFS.
Любой участник сети может запустить DHT ноду, сгенерировать ключи, и хранить данные. 
Для этого ему нужно сгенерировать случайный айди, и сообщить о себе другим нодам.

Для определения на какой ноде сохранить данные, используется алгоритм определения "расстояния" между нодой и ключем. 
Алгоритм прост, берем айди ноды и айди ключа, производим операцию XOR, чем меньше получилось значение, тем ближе нода.
Задача в том чтобы сохранить ключ на максимально близким к ключу нодам, чтобы другие участники сети могли используя 
тот же алгоритм найти ноду которая сможет отдать данные по этому ключу.

### Поиск значения по ключу
Разберем пример с поиском ключа, [подключимся к любой DHT ноде и установим соединение по ADNL UDP](/ADNL-UDP-Internal.md#устройство-пакетов-и-обмен-информацией).

Например мы хотим найти адрес и данные для подключения к RLDP ноде ТОН сайта foundation.ton. Допустим мы уже получили ADNL адрес этого сайта, выполнив Get метод DNS контракта. ADNL адресом в hex представлении будет `516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174`. Теперь наша задача найти ip, порт и публичный ключ ноды имеющей этот адрес.

Чтобы это сделать, нам нужно получить ID DHT ключа, сначала соберем сам DHT ключ:
```
dht.key id:int256 name:bytes idx:int = dht.Key
```
Заполнив эту схему получим:
```
8fde67f6                                                           -- TL ID dht.key
516618cf6cbe9004f6883e742c9a2e3ca53ed02e3e36f4cef62a98ee1e449174   -- наш искомый ADNL адрес
07 61646472657373                                                  -- тип ключа, слово "address" в виде массива bytes
00000000                                                           -- индекс 0 т.к ключ всего 1
```
Далее - получим айди ключа, sha256 хеш от сериализованых выше байтов. Это будет `b30af0538916421b46df4ce580bf3a29316831e0c3323a7f156df0236c5b2f75`

Теперь мы можем приступить к поиску, для этого нам нужно выполнить запрос имеющий [схему](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L197):
```
dht.findValue key:int256 k:int = dht.ValueResult
```
`key` - это айди нашего DHT ключа, а `k` - это "ширина" поиска, чем она меньше тем точнее, но меньше потенциальных нод для опроса. Максимальное k для нод в тоне равно 10, мы можем использовать 6.

Заполним эту структуру, сериализуем и отправим запрос используя схему `adnl.message.query`. [Подробнее об этом можну узнать в другой статье.](/ADNL-UDP-Internal.md#устройство-пакетов-и-обмен-информацией).

В ответ мы можем получить:
* `dht.valueNotFound` - если значение не найдено. 
* `dht.valueFound` - если значение найдено на этой ноде.

###### dht.valueNotFound
Если мы получили `dht.valueNotFound`, ответ будет содержать список нод которые известны запрошеной нами ноде и находятся максимально близко запрошеному нами ключу из списка известных ей нод. В этом случае нам нужно подключиться и добавить полученые ноды к списку известных нам. После этого из списка всех известных нам нод выбрать самую близкую, доступную и еще не опрошеную, и сделать также же запрос к ней. И так пока мы не попробуем все ноды в выбраном нами диапозоне или пока мы не перестанем получать новые ноды.

Разберем поля ответа подробнее, исползуемые схемы:
```
adnl.address.udp ip:int port:int = adnl.Address;
adnl.addressList addrs:(vector adnl.Address) version:int reinit_date:int priority:int expire_at:int = adnl.AddressList;

dht.node id:PublicKey addr_list:adnl.addressList version:int signature:bytes = dht.Node;
dht.nodes nodes:(vector dht.node) = dht.Nodes;

dht.valueNotFound nodes:dht.nodes = dht.ValueResult;
```
`dht.nodes -> nodes` -  список DHT нод (массив).

У каждой ноды есть `id` который является ее публичным ключем, обычно [pub.ed25519](https://github.com/ton-blockchain/ton/blob/master/tl/generate/scheme/ton_api.tl#L47), используется как ключ сервера для подключения к ноде по ADNL. Так же каждая нода имеет список адресов `addr_list:adnl.addressList`, версию и подпись.

Нам нужно обязательно проверять подпись каждой ноды, для этого читаем значение `signature` и обнуляем поле (делаем пустым массивом bytes). После - сериализуем TL структуру `dht.node` с обнуленной подписью, и проверяем `signature` которая была до обнуления на полученных сериализованых байтах, используя ключ из `id`. [[Пример реализации]](https://github.com/xssnick/tonutils-go/blob/udp-rldp-2/adnl/dht/client.go#L91)

Из списка `addrs:(vector adnl.Address)` берем адрес и пробуем установить ADNL UDP соединение, в качестве ключа сервера используем `id` который является публичным ключем.

Чтобы узнать "расстояние" до этой ноды - нам нужно взять [айди ключа](/ADNL-TCP-Liteserver.md#получение-айди-ключа) от ключа из поля `id`, и проверить расстояние операцией XOR от айди ключа ноды и искомого ключа. Если расстояние достаточно небольшое - мы можем делать тот же запрос на эту ноду. И так далее, пока не найдем значение или не будет больше новых нод.

###### dht.valueFound
Ответ будет содержать само значение, подписи, и полную информацию по ключу. 

Разберем поля ответа подробнее, исползуемые схемы:
```
dht.key id:int256 name:bytes idx:int = dht.Key;

dht.updateRule.signature = dht.UpdateRule;
dht.updateRule.anybody = dht.UpdateRule;
dht.updateRule.overlayNodes = dht.UpdateRule;

dht.keyDescription key:dht.key id:PublicKey update_rule:dht.UpdateRule signature:bytes = dht.KeyDescription;

dht.value key:dht.keyDescription value:bytes ttl:int signature:bytes = dht.Value; 

dht.valueFound value:dht.Value = dht.ValueResult;
```

TODO


